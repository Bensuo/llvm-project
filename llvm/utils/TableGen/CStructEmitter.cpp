#include "llvm/Support/Format.h"
#include "llvm/TableGen/TableGenBackend.h"

using namespace llvm;

namespace {
// These aren't strictly necessary, but they allows us to beautify the output.
int indent;
std::string getIndent() { return std::string(indent, ' '); }

class CppStructEmitter {
  // The RecordKeeper is the central database of the parsed and evaluated
  // Tablgen input. It's got everything we need.
  RecordKeeper &RK;

  void emitForwardDecls(raw_ostream &O);
  /* Tablegen class = abstract. It describes the form of the data -> This maps
   * nicely to C++ struct declarations
   * e.g.
   *
   * class Foo { string Name = "Foo"; }
   * would look like this in C++
   * struct Foo { const char *Name; }
   */
  void emitStructDecls(raw_ostream &O);
  /* Tablegen def = concrete instantiation of a `class`. Usually they have
   * names, but in Tablgen they can be anonymous. This backend will probably
   * crash in that situation since we don't do anything about it yet.. It
   * describes the
   *
   *     let Name = "woof" in { def foo : Foo; }
   *
   * would look like this in C++
   *
   *     struct Foo foo{ .Name = "woof };
   */
  void emitStructDefs(raw_ostream &O);

public:
  /* Once we've registered our backend, Tablgen will construct us after parsing
   * and evaluation of the user's Tablegen input and pass us a `RecordKeeper`.
   * The RecordKeeper contains all the `def`s, `class`es, from the input
   * Tablegen - along with some simple debug info and things like assert
   * expressions.
   *
   * For our purposes we're only going to look at classes and defs
   */
  CppStructEmitter(RecordKeeper &RK) : RK(RK) {}
  /* The `llvm-tblgen` binary calls the `run` entry point passing us an
   * `llvm::raw_ostream`. We can print anything we want to it. Our Tablegen
   * backend simply iterates over the `class`es and `def`s in the given
   * `RecordKeeper` and converts them to a C++ representation in as simple a
   * one-to-one mapping as I could express
   */
  void run(raw_ostream &O);
};

static void emitFrontMatter(raw_ostream &O, std::string File) {
  O << "// This code was generated by my fancy tablegen backend from " << File
    << '\n';
  O << "#include <vector>\n\n";
}

void CppStructEmitter::run(raw_ostream &O) {
  // We're going to emit some comments and includes first, then struct
  // declarations based on all the Tablegen `class`es, then finally all the defs
  // as named global variables
  emitFrontMatter(O, RK.getInputFilename());
  emitForwardDecls(O);
  emitStructDecls(O);
  emitStructDefs(O);
}

void CppStructEmitter::emitForwardDecls(raw_ostream &O) {
  O << "// Forward decls. We might need them later\n";
  for (auto &Pair : RK.getClasses()) {
    const std::string Name = Pair.first;
    O << "struct " << Name << ";\n";
  }
  O << "\n\n";
}

int getListDims(ListRecTy *L) {
  int Dims = 1;
  while ((L = dyn_cast<ListRecTy>(L->getElementType())))
    ++Dims;
  return Dims;
}

std::string getListTypeName(ListRecTy *L) {
  RecTy *BaseTy = L->getElementType();
  while ((L = dyn_cast<ListRecTy>(BaseTy)))
    BaseTy = L->getElementType();
  assert(BaseTy);
  return BaseTy->getAsString();
}

void emitFieldType(raw_ostream &O, const RecordVal &Field) {
  indent += 2;
  RecTy *Ty = Field.getType();
  RecordRecTy::RecTyKind Kind = Ty->getRecTyKind();
  StringRef Name = Field.getName();
  O << getIndent();
  switch (Kind) {
  case RecordRecTy::RecTyKind::DagRecTyKind:
    errs() << "DAGs are not supported by the C-struct backend";
    exit(1);
  case RecordRecTy::RecTyKind::ListRecTyKind: {
    auto *List = cast<ListRecTy>(Ty);
    int Dims = getListDims(List);
    std::string TN = getListTypeName(List);
    std::string Vecs;
    for (int I = 0; I < Dims; ++I)
      Vecs += "std::vector<";
    O << Vecs << TN << std::string(Dims, '>') << ' ' << Name << ";\n";
    break;
  }
  case RecordRecTy::RecTyKind::RecordRecTyKind: {
    auto Rec = cast<RecordRecTy>(Ty);
    O << "struct " << Rec->getAsString() << " " << Name << ";\n";
    break;
  }
  case RecordRecTy::RecTyKind::StringRecTyKind:
    O << "const char *" << Name << ";\n";
    break;
  case RecordRecTy::RecTyKind::BitsRecTyKind: {
    unsigned NBits = cast<BitsRecTy>(Ty)->getNumBits();
    assert(NBits <= 32);
    O << "unsigned " << Name << ": " << NBits << ";\n";
    break;
  }
  case RecordRecTy::RecTyKind::BitRecTyKind:
    O << "bool " << Name << ": 1;\n";
    break;
  case RecordRecTy::RecTyKind::IntRecTyKind: {
    O << "int " << Name << ";\n";
    break;
  }
  }
  indent -= 2;
}

void topoSortHelper(SmallPtrSetImpl<const Record *> &Seen,
                    SmallVectorImpl<const Record *> &Sorted, const Record *R) {
  if (Seen.contains(R))
    return;
  for (const RecordVal &Field : R->getValues()) {
    RecTy *Ty = Field.getType();
    RecordRecTy::RecTyKind Kind = Ty->getRecTyKind();
    if (Kind != RecordRecTy::RecTyKind::RecordRecTyKind)
      continue;
    auto *RRTy = cast<RecordRecTy>(Ty);
    auto TypeName = RRTy->getAsString();
    Record *FR = RRTy->getRecordKeeper().getClass(RRTy->getAsString());
    topoSortHelper(Seen, Sorted, FR);
  }
  Seen.insert(R);
  Sorted.push_back(R);
}

void topoSortClasses(RecordKeeper &RK,
                     SmallVectorImpl<const Record *> &Sorted) {
  SmallPtrSet<const Record *, 32> Seen;
  for (auto &Pair : RK.getClasses()) {
    const std::unique_ptr<Record> &R = Pair.second;
    if (Seen.contains(R.get()))
      continue;
    topoSortHelper(Seen, Sorted, R.get());
  }
}

void CppStructEmitter::emitStructDecls(raw_ostream &O) {
  O << "// complete declarations\n";
  SmallVector<const Record *, 32> SortedClasses;
  topoSortClasses(RK, SortedClasses);
  for (const Record *R : SortedClasses) {
    const StringRef Name = R->getName();
    O << "struct " << Name << " {\n";
    assert(R->isClass());
    for (const RecordVal &Field : R->getValues()) {
      emitFieldType(O, Field);
    }
    O << "}; // struct " << Name << "\n\n";
  }
}

void emitInnerValues(raw_ostream &O, Record &R);
std::string stringifyInit(Init *I) {
  assert(I);
  if (isa<StringInit>(I))
    return I->getAsString();
  if (ListInit *List = dyn_cast<ListInit>(I)) {
    std::string Val = "{";
    for (unsigned I = 0, N = List->size(); I < N; ++I) {
      Val += I ? ", " : "";
      Val += stringifyInit(List->getElement(I));
    }
    Val += "}";
    return Val;
  }
  if (BitInit *Bit = dyn_cast<BitInit>(I))
    return Bit->getValue() ? "true" : "false";
  if (BitsInit *Bits = dyn_cast<BitsInit>(I)) {
    uint64_t Val = 0;
    for (unsigned I = 0, N = Bits->getNumBits(); I < N; ++I) {
      Val |= (cast<BitInit>(Bits->getBit(I))->getValue() << I);
    }
    std::string S;
    llvm::raw_string_ostream SS(S);
    SS << format_hex(Val, Bits->getNumBits() / 4 + 1);
    return S;
  }
  if (IntInit *Int = dyn_cast<IntInit>(I)) {
    std::string S;
    llvm::raw_string_ostream SS(S);
    SS << format_decimal(Int->getValue(), 1);
    return S;
  }
  if (DefInit *DI = dyn_cast<DefInit>(I)) {
    Record *Def = DI->getDef();
    std::string S;
    Def->getName();
    llvm::raw_string_ostream SS(S);
    emitInnerValues(SS, *Def);
    return ("{\n" + getIndent() + S + getIndent() + "}");
  }
  return "?";
}

void emitInnerValues(raw_ostream &O, Record &R) {
  indent += 2;
  std::string Spaces(indent, ' ');
  for (const RecordVal &V : R.getValues()) {
    O << Spaces << "." << V.getName() << " = " << stringifyInit(V.getValue())
      << ",\n";
  }
  indent -= 2;
}

void CppStructEmitter::emitStructDefs(raw_ostream &O) {
  for (auto &Pair : RK.getDefs()) {
    Record &R = *Pair.second;
    if (R.isAnonymous())
      continue;
    std::string Name = Pair.first;
    O << "struct " << R.getType()->getAsString() << ' ' << Name << " = {\n";
    emitInnerValues(O, R);
    O << "};\n";
  }
}

} // namespace

/*
 * Tablegen backends register themselves with the `llvm-tblgen` binary via the
 * static `TableGen::Emitter::Optclass`. It doesn't matter what it's called, but
 * it does RAII magic before program startup so it needs to be at global scope.
 * Various bits of LLVM's Pass infrastructure behave this way too, so it's
 * somewhat idiomatic
 */
static TableGen::Emitter::OptClass<CppStructEmitter>
    X("gen-cpp-structs",
      "Generate C++ struct definitions from tablegen classes");
